import java.util.*;

/**
 * Класс DormitoryManagementSystem - центральная система управления общежитием.
 *
 * Это основной класс приложения, который демонстрирует множество важных концепций
 * объектно-ориентированного программирования и работы с коллекциями Java:
 *
 * ПРИНЦИПЫ ООП:
 * - Инкапсуляция: все поля приватные с контролируемым доступом
 * - Полиморфизм: работа с объектами через базовые типы (Person, Student)
 * - Наследование: использование иерархии классов Person -> Student -> DormLeader
 * - Абстракция: сокрытие сложности внутренней реализации
 *
 * КОЛЛЕКЦИИ JAVA:
 * - List<Person> для хранения жильцов с возможностью дублирования и порядка
 * - Set<String> для уникальных номеров комнат без дублирования
 * - Queue<String> для обработки заявок на ремонт в порядке поступления (FIFO)
 * - List<Expense> для учета всех расходов с возможностью сортировки
 *
 * ФУНКЦИОНАЛЬНОСТЬ СИСТЕМЫ:
 * - Управление жильцами (добавление, поиск по различным критериям)
 * - Распределение комнат и контроль доступности
 * - Учет финансовых расходов с категоризацией и анализом
 * - Обработка заявок на техническое обслуживание
 * - Организация мероприятий и координация деятельности
 * - Генерация статистики и отчетов
 *
 * ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ:
 * - Фасад: предоставляет простой интерфейс для сложной системы
 * - Стратегия: использование Comparator для различных способов сортировки
 * - Итератор: обход коллекций различными способами
 *
 * @author Sergiy Danylko
 * @version 1.0
 * @see Person
 * @see Student
 * @see DormLeader
 * @see DormManager
 * @see Expense
 */
public class DormitoryManagementSystem {

    /**
     * Список всех жильцов общежития.
     *
     * Использует ArrayList для:
     * - Быстрого доступа по индексу O(1)
     * - Сохранения порядка добавления жильцов
     * - Возможности хранения дублирующихся объектов
     * - Динамического изменения размера
     *
     * Полиморфизм: хранит объекты типа Person, но может содержать
     * Student, DormLeader, DormManager благодаря наследованию.
     */
    private List<Person> residents;

    /**
     * Множество доступных для заселения комнат.
     *
     * Использует HashSet для:
     * - Быстрой проверки доступности комнаты O(1)
     * - Автоматического исключения дублирующихся номеров
     * - Эффективного добавления/удаления комнат
     *
     * Строки вида "Комната 101", "Комната 102" и т.д.
     */
    private Set<String> availableRooms;

    /**
     * Очередь заявок на техническое обслуживание и ремонт.
     *
     * Использует LinkedList как Queue для:
     * - Обработки заявок в порядке поступления (FIFO - First In, First Out)
     * - Эффективного добавления в конец и удаления из начала O(1)
     * - Справедливого распределения ресурсов на ремонт
     *
     * Демонстрирует принцип очереди в управлении ресурсами.
     */
    private Queue<String> maintenanceQueue;

    /**
     * Список всех финансовых расходов общежития.
     *
     * Использует ArrayList для:
     * - Хранения истории всех трат с временным порядком
     * - Возможности сортировки по различным критериям
     * - Группировки и фильтрации по категориям
     * - Расчета общих сумм и статистики
     *
     * Каждый элемент - объект Expense с описанием, суммой и категорией.
     */
    private List<Expense> expenses;

    /**
     * Конструктор системы управления общежитием.
     *
     * Инициализирует все основные коллекции и создает базовую инфраструктуру:
     *
     * ИНИЦИАЛИЗАЦИЯ КОЛЛЕКЦИЙ:
     * - ArrayList для жильцов - обеспечивает быстрый доступ и сохранение порядка
     * - HashSet для комнат - гарантирует уникальность номеров комнат
     * - LinkedList для очереди ремонта - эффективная реализация FIFO
     * - ArrayList для расходов - поддерживает сортировку и группировку
     *
     * АВТОМАТИЧЕСКАЯ НАСТРОЙКА:
     * - Создает 20 комнат (101-120) как доступные для заселения
     * - Демонстрирует автоматическую инициализацию системы
     * - Использует цикл for для генерации данных
     *
     * ПРИНЦИПЫ ПРОЕКТИРОВАНИЯ:
     * - Инкапсуляция: все поля инициализируются как приватные
     * - Готовность к работе: система сразу готова к использованию
     * - Масштабируемость: легко изменить количество комнат
     */
    public DormitoryManagementSystem() {
        // Инициализация коллекции жильцов - ArrayList для быстрого доступа по индексу
        this.residents = new ArrayList<>();

        // Инициализация множества комнат - HashSet для уникальности и быстрого поиска
        this.availableRooms = new HashSet<>();

        // Инициализация очереди ремонта - LinkedList для эффективной реализации FIFO
        this.maintenanceQueue = new LinkedList<>();

        // Инициализация списка расходов - ArrayList для сортировки и фильтрации
        this.expenses = new ArrayList<>();

        // Автоматическая инициализация доступных комнат (101-120)
        // Демонстрирует использование цикла для создания тестовых данных
        for (int i = 101; i <= 120; i++) {
            availableRooms.add("Комната " + i);
        }
    }

    /**
     * Добавляет нового жильца в систему управления общежитием.
     *
     * ФУНКЦИОНАЛЬНОСТЬ:
     * - Добавляет объект Person в коллекцию residents
     * - Выводит подтверждение с информацией о новом жильце
     * - Использует полиморфизм для работы с любыми наследниками Person
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Полиморфизм: принимает Person, но может быть Student, DormLeader, DormManager
     * - Инкапсуляция: безопасное добавление через публичный метод
     * - Абстракция: вызов introduce() работает для всех типов жильцов
     *
     * @param person объект жильца для добавления в систему
     */
    public void addResident(Person person) {
        residents.add(person);
        System.out.println("Добавлен новый жилец: " + person.introduce());
    }

    /**
     * Находит всех жильцов младше указанного возраста.
     *
     * АЛГОРИТМ ПОИСКА:
     * - Перебирает всех жильцов с помощью enhanced for loop
     * - Сравнивает возраст каждого жильца с максимальным значением
     * - Создает новый список с результатами поиска
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Фильтрация коллекций по критерию
     * - Создание новых коллекций для результатов
     * - Использование enhanced for для обхода
     *
     * @param maxAge максимальный возраст для поиска (не включительно)
     * @return список жильцов младше указанного возраста
     */
    public List<Person> findYoungResidents(int maxAge) {
        List<Person> result = new ArrayList<>();
        for (Person person : residents) {
            if (person.getAge() < maxAge) {
                result.add(person);
            }
        }
        return result;
    }

    /**
     * Находит всех студентов определенного курса.
     *
     * АЛГОРИТМ ПОИСКА:
     * - Проверяет каждого жильца на принадлежность к типу Student
     * - Использует instanceof для безопасной проверки типа
     * - Выполняет приведение типа (casting) для доступа к методам Student
     * - Сравнивает номер курса студента с искомым значением
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Проверка типа с instanceof
     * - Безопасное приведение типов (casting)
     * - Полиморфизм: работа с разными типами в одной коллекции
     * - Фильтрация по специфическим свойствам наследников
     *
     * @param course номер курса для поиска студентов
     * @return список студентов указанного курса
     */
    public List<Student> findStudentsByCourse(int course) {
        List<Student> result = new ArrayList<>();
        for (Person person : residents) {
            if (person instanceof Student) {
                Student student = (Student) person;
                if (student.getCourse() == course) {
                    result.add(student);
                }
            }
        }
        return result;
    }

    /**
     * Находит жильцов по частичному совпадению имени.
     *
     * АЛГОРИТМ ПОИСКА:
     * - Преобразует и имя жильца, и поисковый паттерн в нижний регистр
     * - Использует метод contains() для поиска подстроки
     * - Обеспечивает регистронезависимый поиск
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Работа со строками (toLowerCase, contains)
     * - Регистронезависимый поиск
     * - Гибкость поиска по частичному совпадению
     *
     * @param namePattern часть имени или полное имя для поиска
     * @return список жильцов, чьи имена содержат указанный паттерн
     */
    public List<Person> findResidentsByName(String namePattern) {
        List<Person> result = new ArrayList<>();
        for (Person person : residents) {
            if (person.getName().toLowerCase().contains(namePattern.toLowerCase())) {
                result.add(person);
            }
        }
        return result;
    }

    /**
     * Находит всех жильцов старше или равных указанному возрасту.
     *
     * АЛГОРИТМ ПОИСКА:
     * - Перебирает всех жильцов в коллекции
     * - Сравнивает возраст с минимальным значением (включительно)
     * - Добавляет подходящих жильцов в результирующий список
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Фильтрация по числовому критерию
     * - Использование операторов сравнения
     * - Создание подмножества данных
     *
     * @param minAge минимальный возраст для поиска (включительно)
     * @return список жильцов старше или равных указанному возрасту
     */
    public List<Person> findOlderResidents(int minAge) {
        List<Person> result = new ArrayList<>();
        for (Person person : residents) {
            if (person.getAge() >= minAge) {
                result.add(person);
            }
        }
        return result;
    }

    // =============== МЕТОДЫ МАССОВЫХ ДЕЙСТВИЙ ===============
    // Эти методы демонстрируют применение операций ко всем элементам коллекции
    // Альтернатива функциональному программированию с Consumer<T>

    /**
     * Отображает контактную информацию всех жильцов.
     *
     * ФУНКЦИОНАЛЬНОСТЬ:
     * - Перебирает всех жильцов в системе
     * - Вызывает метод showContactInfo() для каждого жильца
     * - Демонстрирует массовое применение операции
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Итерация по коллекции с enhanced for
     * - Полиморфизм: showContactInfo() работает для всех типов Person
     * - Паттерн "Команда": выполнение одинакового действия для всех объектов
     */
    public void showAllContacts() {
        System.out.println("=== Контакты всех жильцов ===");
        for (Person person : residents) {
            person.showContactInfo();
        }
    }

    /**
     * Заставляет всех студентов в общежитии учиться.
     *
     * АЛГОРИТМ:
     * - Проверяет каждого жильца на принадлежность к типу Student
     * - Использует instanceof для безопасной проверки типа
     * - Приводит тип к Student для доступа к методу study()
     * - Вызывает метод study() только для студентов
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Фильтрация по типу с instanceof
     * - Безопасное приведение типов
     * - Селективное применение операций
     * - Полиморфизм в действии
     */
    public void makeAllStudentsStudy() {
        System.out.println("=== Время учебы! ===");
        for (Person person : residents) {
            if (person instanceof Student) {
                Student student = (Student) person;
                student.study();
            }
        }
    }

    /**
     * Просит всех жильцов представиться.
     *
     * ФУНКЦИОНАЛЬНОСТЬ:
     * - Вызывает абстрактный метод introduce() для каждого жильца
     * - Демонстрирует полиморфное поведение разных типов
     * - Выводит результат представления каждого жильца
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Полиморфизм: introduce() реализован по-разному в каждом классе
     * - Абстракция: единый интерфейс для разных типов объектов
     * - Итерация с выводом результатов
     */
    public void makeAllIntroduce() {
        System.out.println("=== Знакомство ===");
        for (Person person : residents) {
            System.out.println(person.introduce());
        }
    }

    // =============== МЕТОДЫ ПРЕОБРАЗОВАНИЯ ДАННЫХ ===============
    // Эти методы создают новые коллекции на основе существующих данных
    // Альтернатива функциональному программированию с Function<T,R>

    /**
     * Создает список контактов в удобном формате "Имя - Телефон".
     *
     * АЛГОРИТМ ПРЕОБРАЗОВАНИЯ:
     * - Создает новый ArrayList для результатов
     * - Перебирает всех жильцов
     * - Формирует строку контакта из имени и телефона
     * - Добавляет отформатированную строку в результирующий список
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Преобразование коллекции объектов в коллекцию строк
     * - Форматирование данных для удобного отображения
     * - Создание новых структур данных на основе существующих
     *
     * @return список строк с контактной информацией в формате "Имя - Телефон"
     */
    public List<String> getContactList() {
        List<String> contacts = new ArrayList<>();
        for (Person person : residents) {
            String contact = person.getName() + " - " + person.getPhoneNumber();
            contacts.add(contact);
        }
        return contacts;
    }

    /**
     * Извлекает имена всех жильцов в отдельный список.
     *
     * ФУНКЦИОНАЛЬНОСТЬ:
     * - Создает новый список строк
     * - Извлекает имя каждого жильца
     * - Формирует коллекцию только имен
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Извлечение конкретного поля из объектов
     * - Преобразование сложных объектов в простые данные
     * - Создание производных коллекций
     *
     * @return список имен всех жильцов
     */
    public List<String> getAllNames() {
        List<String> names = new ArrayList<>();
        for (Person person : residents) {
            names.add(person.getName());
        }
        return names;
    }

    /**
     * Извлекает возрасты всех жильцов в отдельный список.
     *
     * ФУНКЦИОНАЛЬНОСТЬ:
     * - Создает новый список целых чисел
     * - Извлекает возраст каждого жильца
     * - Формирует числовую коллекцию для анализа
     *
     * ПРИМЕНЕНИЕ:
     * - Статистический анализ возрастного состава
     * - Вычисление среднего возраста
     * - Поиск минимального/максимального возраста
     *
     * @return список возрастов всех жильцов
     */
    public List<Integer> getAllAges() {
        List<Integer> ages = new ArrayList<>();
        for (Person person : residents) {
            ages.add(person.getAge());
        }
        return ages;
    }

    /**
     * Создает краткую сводку информации о всех жильцах.
     *
     * АЛГОРИТМ ФОРМИРОВАНИЯ:
     * - Создает базовую информацию "Имя (возраст лет)" для каждого жильца
     * - Проверяет тип объекта с instanceof
     * - Добавляет специфическую информацию для студентов (номер курса)
     * - Формирует единый список сводной информации
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Условное форматирование данных
     * - Проверка типов и приведение
     * - Создание информативных строковых представлений
     * - Полиморфная обработка разных типов объектов
     *
     * @return список строк с краткой информацией о каждом жильце
     */
    public List<String> getResidentsSummary() {
        List<String> summary = new ArrayList<>();
        for (Person person : residents) {
            String info = person.getName() + " (" + person.getAge() + " лет)";
            if (person instanceof Student) {
                Student student = (Student) person;
                info += " - " + student.getCourse() + " курс";
            }
            summary.add(info);
        }
        return summary;
    }

    // =============== МЕТОДЫ СОРТИРОВКИ И УПОРЯДОЧИВАНИЯ ===============

    /**
     * Сортирует список жильцов по заданному критерию.
     *
     * АЛГОРИТМ СОРТИРОВКИ:
     * - Если comparator == null, использует естественную сортировку (Comparable)
     * - Иначе применяет переданный Comparator для кастомной сортировки
     * - Модифицирует исходную коллекцию residents
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Паттерн "Стратегия": разные алгоритмы сортировки через Comparator
     * - Интерфейс Comparable для естественного порядка
     * - Гибкость сортировки по различным критериям
     * - Использование Collections.sort() и List.sort()
     *
     * ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
     * - sortResidents(null) - сортировка по имени (естественный порядок)
     * - sortResidents(Comparator.comparing(Person::getAge)) - по возрасту
     * - sortResidents(Comparator.comparing(Person::getName).reversed()) - по имени в обратном порядке
     *
     * @param comparator объект для сравнения элементов, null для естественной сортировки
     */
    public void sortResidents(Comparator<Person> comparator) {
        if (comparator == null) {
            // Используем естественную сортировку через интерфейс Comparable
            Collections.sort(residents);
        } else {
            // Используем переданный Comparator для кастомной сортировки
            residents.sort(comparator);
        }
    }

    // =============== УПРАВЛЕНИЕ ФИНАНСАМИ ===============

    /**
     * Добавляет новый расход в систему учета финансов.
     *
     * ФУНКЦИОНАЛЬНОСТЬ:
     * - Создает новый объект Expense с переданными параметрами
     * - Добавляет расход в коллекцию expenses
     * - Обеспечивает централизованный учет всех трат
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Инкапсуляция: создание объектов через конструктор
     * - Агрегация: система содержит коллекцию расходов
     * - Категоризация данных для последующего анализа
     *
     * @param description описание расхода
     * @param amount сумма расхода
     * @param category категория расхода (например, "Еда", "Ремонт", "Коммунальные")
     */
    public void addExpense(String description, double amount, String category) {
        expenses.add(new Expense(description, amount, category));
    }

    /**
     * Находит все расходы определенной категории.
     *
     * АЛГОРИТМ ФИЛЬТРАЦИИ:
     * - Перебирает все расходы в системе
     * - Сравнивает категорию каждого расхода с искомой
     * - Добавляет подходящие расходы в результирующий список
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Фильтрация коллекций по критерию
     * - Работа со строками (equals для точного сравнения)
     * - Создание подмножеств данных для анализа
     *
     * @param category категория для поиска расходов
     * @return список расходов указанной категории
     */
    public List<Expense> getExpensesByCategory(String category) {
        List<Expense> result = new ArrayList<>();
        for (Expense expense : expenses) {
            if (expense.getCategory().equals(category)) {
                result.add(expense);
            }
        }
        return result;
    }

    /**
     * Вычисляет общую сумму всех расходов в системе.
     *
     * АЛГОРИТМ ПОДСЧЕТА:
     * - Инициализирует счетчик нулем
     * - Перебирает все расходы
     * - Суммирует суммы всех расходов
     * - Возвращает итоговую сумму
     *
     * ДЕМОНСТРИРУЕМЫЕ КОНЦЕПЦИИ:
     * - Агрегирующие вычисления над коллекциями
     * - Работа с числовыми данными (double)
     * - Аккумулирование значений в цикле
     *
     * @return общая сумма всех расходов
     */
    public double calculateTotalExpenses() {
        double total = 0;
        for (Expense expense : expenses) {
            total += expense.getAmount();
        }
        return total;
    }

    /**
     * Находит все расходы, превышающие указанную минимальную сумму.
     *
     * АЛГОРИТМ ФИЛЬТРАЦИИ:
     * - Перебирает все расходы в системе
     * - Сравнивает сумму каждого расхода с минимальным порогом
     * - Включает расходы, которые больше или равны минимальной сумме
     *
     * ПРИМЕНЕНИЕ:
     * - Анализ крупных трат
     * - Поиск расходов для оптимизации бюджета
     * - Выявление значительных финансовых операций
     *
     * @param minAmount минимальная сумма для фильтрации расходов
     * @return список расходов, превышающих указанную сумму
     */
    public List<Expense> getMostExpensiveItems(double minAmount) {
        List<Expense> result = new ArrayList<>();
        for (Expense expense : expenses) {
            if (expense.getAmount() >= minAmount) {
                result.add(expense);
            }
        }
        return result;
    }

    /**
     * ДОБАВЛЕНИЕ ЗАЯВКИ НА РЕМОНТ
     *
     * Метод демонстрирует работу с очередью (Queue) для управления заявками на ремонт.
     * Использует принцип FIFO (First In, First Out) для обработки заявок.
     *
     * КОНЦЕПЦИИ ООП:
     * - Инкапсуляция: скрывает детали работы с очередью
     * - Абстракция: предоставляет простой интерфейс для добавления заявок
     *
     * СТРУКТУРЫ ДАННЫХ:
     * - Queue (LinkedList): обеспечивает порядок обработки заявок
     * - offer(): добавляет элемент в конец очереди
     *
     * @param request описание заявки на ремонт
     */
    public void addMaintenanceRequest(String request) {
        maintenanceQueue.offer(request);
        System.out.println("Добавлена заявка на ремонт: " + request);
    }

    /**
     * ОБРАБОТКА ЗАЯВКИ НА РЕМОНТ
     *
     * Метод извлекает и обрабатывает первую заявку из очереди.
     * Демонстрирует принцип FIFO и безопасную работу с пустой очередью.
     *
     * АЛГОРИТМ:
     * - poll(): извлекает и удаляет первый элемент очереди
     * - Возвращает null, если очередь пуста (безопасная операция)
     * - Проверяет результат перед обработкой
     *
     * ПРИМЕНЕНИЕ:
     * - Система управления задачами
     * - Обработка запросов по порядку поступления
     * - Планирование работ по техническому обслуживанию
     */
    public void processMaintenanceRequest() {
        String request = maintenanceQueue.poll();
        if (request != null) {
            System.out.println("Обрабатывается заявка: " + request);
        } else {
            System.out.println("Нет заявок на ремонт");
        }
    }

    /**
     * ЗАСЕЛЕНИЕ В КОМНАТУ
     *
     * Метод демонстрирует работу с множеством (Set) для управления доступными комнатами.
     * Показывает принципы управления ресурсами и проверки доступности.
     *
     * КОНЦЕПЦИИ ООП:
     * - Инкапсуляция: скрывает логику управления комнатами
     * - Полиморфизм: работает с любым типом Person
     *
     * СТРУКТУРЫ ДАННЫХ:
     * - Set (HashSet): обеспечивает уникальность номеров комнат
     * - iterator(): получает доступ к элементам множества
     *
     * АЛГОРИТМ:
     * - Проверяет наличие свободных комнат
     * - Извлекает первую доступную комнату
     * - Удаляет комнату из списка доступных
     * - Возвращает результат операции
     *
     * @param person жилец для заселения
     * @return true если заселение успешно, false если нет свободных комнат
     */
    public boolean assignRoom(Person person) {
        if (!availableRooms.isEmpty()) {
            String room = availableRooms.iterator().next();
            availableRooms.remove(room);
            System.out.println(person.getName() + " заселен в " + room);
            return true;
        } else {
            System.out.println("Нет свободных комнат для " + person.getName());
            return false;
        }
    }

    /**
     * ДЕМОНСТРАЦИЯ РАБОТЫ С ИТЕРАТОРАМИ
     *
     * Метод показывает использование паттерна Iterator для безопасного обхода коллекции.
     * Демонстрирует альтернативный способ перебора элементов списка.
     *
     * ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ:
     * - Iterator: предоставляет единообразный способ обхода коллекций
     * - Инкапсуляция: скрывает внутреннюю структуру коллекции
     *
     * ПРЕИМУЩЕСТВА ITERATOR:
     * - Безопасность: предотвращает модификацию во время обхода
     * - Универсальность: работает с любыми коллекциями
     * - Контроль: позволяет управлять процессом итерации
     *
     * ПРИМЕНЕНИЕ:
     * - Обход больших коллекций
     * - Безопасная итерация в многопоточной среде
     * - Реализация сложных алгоритмов обхода
     */
    public void showAllResidentsWithIterator() {
        System.out.println("\n=== Список всех жильцов (через Iterator) ===");
        Iterator<Person> iterator = residents.iterator();
        int count = 1;
        while (iterator.hasNext()) {
            Person person = iterator.next();
            System.out.println(count + ". " + person.toString());
            count++;
        }
    }

    /**
     * ОРГАНИЗАЦИЯ МЕРОПРИЯТИЯ ВСЕМИ ОРГАНИЗАТОРАМИ
     *
     * Метод демонстрирует полиморфизм и проверку типов во время выполнения.
     * Показывает, как разные классы могут реализовывать один интерфейс по-разному.
     *
     * КОНЦЕПЦИИ ООП:
     * - Полиморфизм: разные реализации метода organizeEvent()
     * - Проверка типов: instanceof для определения возможностей объекта
     * - Приведение типов: безопасное преобразование к интерфейсу
     *
     * АЛГОРИТМ:
     * - Перебирает всех жильцов
     * - Проверяет, реализует ли жилец интерфейс StudentEventOrganizer
     * - Приводит тип к интерфейсу
     * - Вызывает метод организации мероприятия
     *
     * ПРИМЕНЕНИЕ:
     * - Координация деятельности разных типов объектов
     * - Реализация командных операций
     * - Демонстрация полиморфного поведения
     *
     * @param eventName название организуемого мероприятия
     */
    public void organizeEventByAllOrganizers(String eventName) {
        System.out.println("\n=== Организация мероприятия: " + eventName + " ===");
        for (Person person : residents) {
            if (person instanceof StudentEventOrganizer) {
                StudentEventOrganizer organizer = (StudentEventOrganizer) person;
                organizer.organizeEvent(eventName);
            }
        }
    }

    /**
     * ПОКАЗАТЬ СТАТИСТИКУ ОБЩЕЖИТИЯ
     *
     * Метод демонстрирует сбор и анализ данных из различных коллекций системы.
     * Показывает применение проверки типов и подсчета объектов разных классов.
     *
     * КОНЦЕПЦИИ ООП:
     * - Полиморфизм: работа с объектами разных типов через базовый класс
     * - Проверка типов: instanceof для классификации объектов
     * - Инкапсуляция: использование методов доступа к данным
     *
     * АЛГОРИТМ АНАЛИЗА:
     * - Перебирает всех жильцов
     * - Классифицирует их по типам (DormLeader, Student, DormManager)
     * - Подсчитывает количество в каждой категории
     * - Собирает статистику по ресурсам системы
     *
     * ДЕМОНСТРИРУЕМЫЕ ВОЗМОЖНОСТИ:
     * - Анализ состава жильцов
     * - Мониторинг ресурсов (комнаты, заявки)
     * - Финансовая отчетность
     * - Системная аналитика
     *
     * ПРИМЕНЕНИЕ:
     * - Административная отчетность
     * - Мониторинг системы
     * - Планирование ресурсов
     * - Анализ эффективности
     */
    public void showStatistics() {
        System.out.println("\n📊 === СТАТИСТИКА ОБЩЕЖИТИЯ ===");
        System.out.println("Всего жильцов: " + residents.size());

        // Подсчет студентов
        int studentCount = 0;
        int leaderCount = 0;
        int managerCount = 0;

        for (Person person : residents) {
            if (person instanceof DormLeader) {
                leaderCount++;
            } else if (person instanceof Student) {
                studentCount++;
            } else if (person instanceof DormManager) {
                managerCount++;
            }
        }

        System.out.println("Студентов: " + studentCount);
        System.out.println("Старост: " + leaderCount);
        System.out.println("Комендантов: " + managerCount);
        System.out.println("Свободных комнат: " + availableRooms.size());
        System.out.println("Заявок на ремонт: " + maintenanceQueue.size());
        System.out.println("Общие расходы: " + calculateTotalExpenses() + " грн.");
    }

    // Геттеры
    public List<Person> getResidents() { return new ArrayList<>(residents); }
    public List<Expense> getExpenses() { return new ArrayList<>(expenses); }
    public Set<String> getAvailableRooms() { return new HashSet<>(availableRooms); }
}
